{"version":3,"file":"ngxs-store-operators.js","sources":["@ngxs/store/operators/append.ts","@ngxs/store/operators/compose.ts","@ngxs/store/operators/utils.ts","@ngxs/store/operators/iif.ts","@ngxs/store/operators/insert-item.ts","@ngxs/store/operators/patch.ts","@ngxs/store/operators/update-item.ts","@ngxs/store/operators/remove-item.ts"],"names":[],"mappings":"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","sourcesContent":["import { StateOperator } from '@ngxs/store';\nimport { RepairType } from './utils';\n\n/**\n * @param items - Specific items to append to the end of an array\n */\nexport function append<T>(items: T[]): StateOperator<RepairType<T>[]> {\n  return function appendOperator(existing: Readonly<RepairType<T>[]>): RepairType<T>[] {\n    // If `items` is `undefined` or `null` or `[]` but `existing` is provided\n    // just return `existing`\n    const itemsNotProvidedButExistingIs = (!items || !items.length) && existing;\n    if (itemsNotProvidedButExistingIs) {\n      return existing as RepairType<T>[];\n    }\n\n    if (Array.isArray(existing)) {\n      return existing.concat(items as RepairType<T>[]);\n    }\n\n    // For example if some property is added dynamically\n    // and didn't exist before thus it's not `ArrayLike`\n    return items as RepairType<T>[];\n  };\n}\n","import { StateOperator } from '@ngxs/store';\n\nexport function compose<T>(...operators: StateOperator<T>[]): StateOperator<T> {\n  return function composeOperator(existing: Readonly<T>): T {\n    return operators.reduce((accumulator, operator) => operator(accumulator), existing);\n  };\n}\n","import { StateOperator } from '@ngxs/store';\n\nimport { Predicate } from './internals';\n\nexport function isStateOperator<T>(value: T | StateOperator<T>): value is StateOperator<T> {\n  return typeof value === 'function';\n}\n\nexport function isUndefined(value: any): value is undefined {\n  return typeof value === 'undefined';\n}\n\nexport function isPredicate<T>(value: Predicate<T> | boolean | number): value is Predicate<T> {\n  return typeof value === 'function';\n}\n\nexport function isNumber(value: any): value is number {\n  return typeof value === 'number';\n}\n\nexport function invalidIndex(index: number): boolean {\n  return Number.isNaN(index) || index === -1;\n}\n\nexport function isNil<T>(value: T | null | undefined): value is null | undefined {\n  return value === null || isUndefined(value);\n}\n\nexport type RepairType<T> = T extends true ? boolean : (T extends false ? boolean : T);\n","import { StateOperator } from '@ngxs/store';\n\nimport { isStateOperator, isUndefined, isPredicate, RepairType } from './utils';\nimport { Predicate } from './internals';\n\nfunction retrieveValue<T>(\n  operatorOrValue: StateOperator<T> | T,\n  existing?: Readonly<RepairType<T>>\n): RepairType<T> {\n  // If state operator is a function\n  // then call it with an original value\n  if (isStateOperator(operatorOrValue)) {\n    const value = operatorOrValue(existing! as Readonly<T>);\n    return value as RepairType<T>;\n  }\n\n  // If operator or value was not provided\n  // e.g. `elseOperatorOrValue` is `undefined`\n  // then we just return an original value\n  if (isUndefined(operatorOrValue)) {\n    return (<any>existing)! as RepairType<T>;\n  }\n\n  return operatorOrValue as RepairType<T>;\n}\n\n/**\n * @param condition - Condition can be a plain boolean value or a function,\n * that returns boolean, also this function can take a value as an argument\n * to which this state operator applies\n * @param trueOperatorOrValue - Any value or a state operator\n * @param elseOperatorOrValue - Any value or a state operator\n */\nexport function iif<T>(\n  condition: Predicate<T> | boolean,\n  trueOperatorOrValue: StateOperator<T> | T,\n  elseOperatorOrValue?: StateOperator<T> | T\n): StateOperator<RepairType<T>> {\n  return function iifOperator(existing: Readonly<RepairType<T>>): RepairType<T> {\n    // Convert the value to a boolean\n    let result = !!condition;\n    // but if it is a function then run it to get the result\n    if (isPredicate(condition)) {\n      result = condition(existing);\n    }\n\n    if (result) {\n      return retrieveValue<T>(trueOperatorOrValue, existing as RepairType<T>);\n    }\n\n    return retrieveValue<T>(elseOperatorOrValue!, existing as RepairType<T>);\n  };\n}\n","import { StateOperator } from '@ngxs/store';\nimport { isNil, RepairType } from './utils';\n\n/**\n * @param value - Value to insert\n * @param [beforePosition] -  Specified index to insert value before, optional\n */\nexport function insertItem<T>(\n  value: T,\n  beforePosition?: number\n): StateOperator<RepairType<T>[]> {\n  return function insertItemOperator(existing: Readonly<RepairType<T>[]>): RepairType<T>[] {\n    // Have to check explicitly for `null` and `undefined`\n    // because `value` can be `0`, thus `!value` will return `true`\n    if (isNil(value) && existing) {\n      return existing as RepairType<T>[];\n    }\n\n    // Property may be dynamic and might not existed before\n    if (!Array.isArray(existing)) {\n      return [value as RepairType<T>];\n    }\n\n    const clone = existing.slice();\n\n    let index = 0;\n\n    // No need to call `isNumber`\n    // as we are checking `> 0` not `>= 0`\n    // everything except number will return false here\n    if (beforePosition! > 0) {\n      index = beforePosition!;\n    }\n\n    clone.splice(index, 0, value as RepairType<T>);\n    return clone;\n  };\n}\n","import { StateOperator } from '@ngxs/store';\nimport { isStateOperator } from './utils';\n\nexport type PatchSpec<T> = { [P in keyof T]?: T[P] | StateOperator<NonNullable<T[P]>> };\n\ntype PatchValues<T> = {\n  readonly [P in keyof T]?: T[P] extends (...args: any[]) => infer R ? R : T[P];\n};\n\ntype PatchOperator<T> = <U extends PatchValues<T>>(existing: Readonly<U>) => U;\n\nexport function patch<T>(patchObject: PatchSpec<T>): PatchOperator<T> {\n  return function patchStateOperator<U extends PatchValues<T>>(existing: Readonly<U>): U {\n    let clone = null;\n    for (const k in patchObject) {\n      const newValue = patchObject[k];\n      const existingPropValue = existing[k];\n      const newPropValue = isStateOperator(newValue)\n        ? newValue(<any>existingPropValue)\n        : newValue;\n      if (newPropValue !== existingPropValue) {\n        if (!clone) {\n          clone = { ...(<any>existing) };\n        }\n        clone[k] = newPropValue;\n      }\n    }\n    return clone || existing;\n  };\n}\n","import { StateOperator } from '@ngxs/store';\n\nimport { isStateOperator, isPredicate, isNumber, invalidIndex, RepairType } from './utils';\nimport { Predicate } from './internals';\n\n/**\n * @param selector - Index of item in the array or a predicate function\n * that can be provided in `Array.prototype.findIndex`\n * @param operatorOrValue - New value under the `selector` index or a\n * function that can be applied to an existing value\n */\nexport function updateItem<T>(\n  selector: number | Predicate<T>,\n  operatorOrValue: T | StateOperator<T>\n): StateOperator<RepairType<T>[]> {\n  return function updateItemOperator(existing: Readonly<RepairType<T>[]>): RepairType<T>[] {\n    let index = -1;\n\n    if (isPredicate(selector)) {\n      index = existing.findIndex(selector);\n    } else if (isNumber(selector)) {\n      index = selector;\n    }\n\n    if (invalidIndex(index)) {\n      return existing as RepairType<T>[];\n    }\n\n    let value: T = null!;\n    // Need to check if the new item value will change the existing item value\n    // then, only if it will change it then clone the array and set the item\n    if (isStateOperator(operatorOrValue)) {\n      value = operatorOrValue(existing[index] as Readonly<T>);\n    } else {\n      value = operatorOrValue;\n    }\n\n    // If the value hasn't been mutated\n    // then we just return `existing` array\n    if (value === existing[index]) {\n      return existing as RepairType<T>[];\n    }\n\n    const clone = existing.slice();\n    clone[index] = value as RepairType<T>;\n    return clone;\n  };\n}\n","import { StateOperator } from '@ngxs/store';\nimport { Predicate } from './internals';\nimport { isPredicate, isNumber, invalidIndex, RepairType } from './utils';\n\n/**\n * @param selector - index or predicate to remove an item from an array by\n */\nexport function removeItem<T>(\n  selector: number | Predicate<T>\n): StateOperator<RepairType<T>[]> {\n  return function removeItemOperator(existing: Readonly<RepairType<T>[]>): RepairType<T>[] {\n    let index = -1;\n\n    if (isPredicate(selector)) {\n      index = existing.findIndex(selector);\n    } else if (isNumber(selector)) {\n      index = selector;\n    }\n\n    if (invalidIndex(index)) {\n      return existing as RepairType<T>[];\n    }\n\n    const clone = existing.slice();\n    clone.splice(index, 1);\n    return clone;\n  };\n}\n"]}