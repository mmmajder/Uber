{"version":3,"file":"ngxs-store-internals.js","sources":["@ngxs/store/internals/angular.ts","@ngxs/store/internals/ngxs-bootstrapper.ts","@ngxs/store/internals/memoize.ts","@ngxs/store/internals/initial-state.ts","@ngxs/store/internals/internal-tokens.ts"],"names":[],"mappings":";;;;;;;;;;;AAKA,SAAgB,mBAAmB;AAAK;AAC8C;AACzB;AAC6C;AACF;AAExG;AACE,IAAA,QACE,OAAO,SAAS,KAAK,WAAW;AACpC,QAAI,OAAO,OAAO,KAAK,WAAW;AAClC,QAAI,OAAO,IAAI,KAAK,WAAW;AAC/B,QAAI,OAAO,KAAK,KAAK,WAAW,EAC5B;AACJ,CAAC;AACD;AAAC;AAAI;AAAkC;AAAqH;ACnB5J,MAIa,gBAAgB;AAC7B,IAFA;AACE;AAAY;AAEuD;AAAY,QAEvE,eAAU,GAAG,IAAI,aAAa,CAAU,CAAC,CAAC,CAAC;AACrD,KAaC;AACD;AAAQ;AAAmB;AAAQ,IAbjC,IAAI,gBAAgB;AAAK,QACvB,OAAO,IAAI,CAAC,UAAU,CAAC,YAAY,EAAE,CAAC;AAC1C,KAAG;AACH;AAEC;AACE;AACE;AACa;AACd,IADF,SAAS;AAAK,QACZ,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC/B,QAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC;AAC/B,KAAG;AACH;4CAnBC,UAAU;;;;gDACT;AAAC;AAAa;AAAQ;AAEmD;AACtE;AACU;AAAQ,IAArB,sCAAmD;AACrD;AACC;AAAC;AAAI;AAAkC;AAKe;AAAI;AAAI;AAAgB;AACrE;AAAe;AChBzB,SAAS,oBAAoB,CAAC,CAAM,EAAE,CAAM;AAC5C,IAAE,OAAO,CAAC,KAAK,CAAC,CAAC;AACjB,CAAC;AACD;AACG;AAA4B;AAClB;AAAmB;AAC/B;AAFD,SAAS,0BAA0B,CACjC,aAA0C,EAC1C,IAAuB,EACvB,IAAuB;AACtB,IACD,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM,EAAE;AACrE,QAAI,OAAO,KAAK,CAAC;AACjB,KAAG;AACH;AAEC;AAAqB,UAAd,MAAM,GAAG,IAAI,CAAC,MAAM;AAC5B,IAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;AACnC,QAAI,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;AAC1C,YAAM,OAAO,KAAK,CAAC;AACnB,SAAK;AACL,KAAG;AACH,IACE,OAAO,IAAI,CAAC;AACd,CAAC;AACD;AACG;AAC2C;AACkC;AAC9E;AACQ;AAEA;AAAmB;AAA6B;AAExD;AAFF,SAAgB,OAAO,CACrB,IAAO,EACP,aAAa,GAAG,oBAAoB;AACnC;AACc,QAAX,QAAQ,GAAsB,IAAI;AACxC;AAAqB,QAAf,UAAU,GAAQ,IAAI;AAC5B;AACE;AAAQ;AACL;AAAQ,IADX,SAAS,QAAQ;AACnB,QAAI,IAAI,CAAC,0BAA0B,CAAC,aAAa,EAAE,QAAQ,EAAE,SAAS,CAAC,EAAE;AACzE;AACM,YAAA,UAAU,GAAG,oBAAW,IAAI,IAAE,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;AAC3D,SAAK;AACL,QACI,QAAQ,GAAG,SAAS,CAAC;AACzB,QAAI,OAAO,UAAU,CAAC;AACtB,KAAG;AACH,IAAE,oBAAM,QAAQ,IAAE,KAAK;AAAQ;AACpB;AAAQ,IADO;AACzB;AACI,QAAD,QAAQ,GAAG,IAAI,CAAC;AACpB,QAAI,UAAU,GAAG,IAAI,CAAC;AACtB,KAAG,CAAA,CAAC;AACJ,IAAE,0BAAO,QAAQ,GAAM;AACvB,CAAC;AACD;AAAC;AAAI;AAAkC;AAAqH;ACrD5J;AAGA,MAAa,mBAAmB,GAAG,IAAI,cAAc,CAAM,qBAAqB,CAAC;AAEjF,MAAa,YAAY;AACzB;AAAQ;AAAwB;AAExB;AAAQ,IAAP,OAAO,GAAG,CAAC,KAAkB;AACtC,QAAI,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AACvB,KAAG;AACH;AACO;AAAmB;AAAQ,IAAzB,OAAO,GAAG;AAAK;AACZ,cAAF,KAAK,GAAgB,IAAI,CAAC,KAAK;AACzC,QAAI,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;AACpB,QAAI,OAAO,KAAK,CAAC;AACjB,KAAG;AACH;AAXiB,kBAAK,GAAgB,EAAE,CAAC;AACzC;AACY;AAAQ;AAAiB;AAC1B;AAAQ,IAHjB,mBAAuC;AACzC;AACC;AAAC;AAAI;AAAkC;AAMlC;ACdN;AAAI;AAG6C;AAAa;AAE9D,MAAa,0BAA0B,GAAwB,IAAI,cAAc,CAC/E,+BAA+B,CAChC;AACD;AACG;AACuF;AAElF;AAAR,MAAa,kBAAkB,GAAwB,IAAI,cAAc,CACvE,wBAAwB,CACzB;AACD;AAAC;AAAI;AAAkC;AAAqH;AAAI;AAAC;AAAI;AAAkC;AAAqH;AAAI;AAAC;AAA8I","sourcesContent":["declare const __karma__: unknown;\ndeclare const jasmine: unknown;\ndeclare const jest: unknown;\ndeclare const Mocha: unknown;\n\nexport function isAngularInTestMode(): boolean {\n  // This is safe to check for these properties in the following way since `typeof` does not\n  // throw an exception if the value does not exist in the scope.\n  // We should not try to read these values from the global scope (e.g. `Éµglobal` from the `@angular/core`).\n  // This is related to how these frameworks compile and execute modules. E.g. Jest wraps the module into\n  // its internal code where `jest` variable exists in the scope. It cannot be read from the global scope, e.g.\n  // this will return undefined `global.jest`, but `jest` will not equal undefined.\n  return (\n    typeof __karma__ !== 'undefined' ||\n    typeof jasmine !== 'undefined' ||\n    typeof jest !== 'undefined' ||\n    typeof Mocha !== 'undefined'\n  );\n}\n","import { Injectable } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\n\n@Injectable()\nexport class NgxsBootstrapper {\n  /**\n   * Use `ReplaySubject`, thus we can get cached value even if the stream is completed\n   */\n  private bootstrap$ = new ReplaySubject<boolean>(1);\n\n  get appBootstrapped$(): Observable<boolean> {\n    return this.bootstrap$.asObservable();\n  }\n\n  /**\n   * This event will be emitted after attaching `ComponentRef` of the root component\n   * to the tree of views, that's a signal that application has been fully rendered\n   */\n  bootstrap(): void {\n    this.bootstrap$.next(true);\n    this.bootstrap$.complete();\n  }\n}\n","function defaultEqualityCheck(a: any, b: any) {\n  return a === b;\n}\n\nfunction areArgumentsShallowlyEqual(\n  equalityCheck: (a: any, b: any) => boolean,\n  prev: IArguments | null,\n  next: IArguments | null\n) {\n  if (prev === null || next === null || prev.length !== next.length) {\n    return false;\n  }\n\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n  const length = prev.length;\n  for (let i = 0; i < length; i++) {\n    if (!equalityCheck(prev[i], next[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Memoize a function on its last inputs only.\n * Originally from: https://github.com/reduxjs/reselect/blob/master/src/index.js\n *\n * @ignore\n */\nexport function memoize<T extends (...args: any[]) => any>(\n  func: T,\n  equalityCheck = defaultEqualityCheck\n): T {\n  let lastArgs: IArguments | null = null;\n  let lastResult: any = null;\n  // we reference arguments instead of spreading them for performance reasons\n  function memoized() {\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\n      // apply arguments instead of spreading for performance.\n      lastResult = (<Function>func).apply(null, arguments);\n    }\n\n    lastArgs = arguments;\n    return lastResult;\n  }\n  (<any>memoized).reset = function() {\n    // The hidden (for now) ability to reset the memoization\n    lastArgs = null;\n    lastResult = null;\n  };\n  return memoized as T;\n}\n","import { InjectionToken } from '@angular/core';\nimport { PlainObject } from './symbols';\n\nexport const INITIAL_STATE_TOKEN = new InjectionToken<any>('INITIAL_STATE_TOKEN');\n\nexport class InitialState {\n  private static value: PlainObject = {};\n\n  public static set(state: PlainObject) {\n    this.value = state;\n  }\n\n  public static pop(): PlainObject {\n    const state: PlainObject = this.value;\n    this.value = {};\n    return state;\n  }\n}\n","import { InjectionToken } from '@angular/core';\n\n/**\n * @see StateContextFactory as it's referenced by this token to be accessed by plugins internally\n */\nexport const NGXS_STATE_CONTEXT_FACTORY: InjectionToken<any> = new InjectionToken(\n  'Internals.StateContextFactory'\n);\n\n/**\n * @see StateFactory as it's referenced by this token to be accessed by plugins internally\n */\nexport const NGXS_STATE_FACTORY: InjectionToken<any> = new InjectionToken(\n  'Internals.StateFactory'\n);\n"]}