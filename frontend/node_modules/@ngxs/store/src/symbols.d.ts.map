{"version":3,"file":"symbols.d.ts","sources":["symbols.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { InjectionToken, Type } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { PlainObject, StateClass } from '@ngxs/store/internals';\nimport { SharedSelectorOptions } from './internal/internals';\nimport { NgxsExecutionStrategy } from './execution/symbols';\nimport { StateToken } from './state-token/state-token';\nexport declare const ROOT_STATE_TOKEN: InjectionToken<any>;\nexport declare const FEATURE_STATE_TOKEN: InjectionToken<any>;\nexport declare const NGXS_PLUGINS: InjectionToken<{}>;\nexport declare const META_KEY = \"NGXS_META\";\nexport declare const META_OPTIONS_KEY = \"NGXS_OPTIONS_META\";\nexport declare const SELECTOR_META_KEY = \"NGXS_SELECTOR_META\";\nexport declare type NgxsLifeCycle = Partial<NgxsOnChanges> & Partial<NgxsOnInit> & Partial<NgxsAfterBootstrap>;\nexport declare type NgxsPluginFn = (state: any, mutation: any, next: NgxsNextPluginFn) => any;\n/**\n * The NGXS config settings.\n */\nexport declare class NgxsConfig {\n    /**\n     * Run in development mode. This will add additional debugging features:\n     * - Object.freeze on the state and actions to guarantee immutability\n     * (default: false)\n     *\n     * Note: this property will be accounted only in development mode when using the Ivy compiler.\n     * It makes sense to use it only during development to ensure there're no state mutations.\n     * When building for production, the Object.freeze will be tree-shaken away.\n     */\n    developmentMode: boolean;\n    compatibility: {\n        /**\n         * Support a strict Content Security Policy.\n         * This will circumvent some optimisations that violate a strict CSP through the use of `new Function(...)`.\n         * (default: false)\n         */\n        strictContentSecurityPolicy: boolean;\n    };\n    /**\n     * Determines the execution context to perform async operations inside. An implementation can be\n     * provided to override the default behaviour where the async operations are run\n     * outside Angular's zone but all observable behaviours of NGXS are run back inside Angular's zone.\n     * These observable behaviours are from:\n     *   `@Select(...)`, `store.select(...)`, `actions.subscribe(...)` or `store.dispatch(...).subscribe(...)`\n     * Every `zone.run` causes Angular to run change detection on the whole tree (`app.tick()`) so of your\n     * application doesn't rely on zone.js running change detection then you can switch to the\n     * `NoopNgxsExecutionStrategy` that doesn't interact with zones.\n     * (default: null)\n     */\n    executionStrategy: Type<NgxsExecutionStrategy>;\n    /**\n     * Defining the default state before module initialization\n     * This is convenient if we need to create a define our own set of states.\n     * @deprecated will be removed after v4\n     * (default: {})\n     */\n    defaultsState: PlainObject;\n    /**\n     * Defining shared selector options\n     */\n    selectorOptions: SharedSelectorOptions;\n    constructor();\n}\nexport declare type StateOperator<T> = (existing: Readonly<T>) => T;\n/**\n * State context provided to the actions in the state.\n */\nexport interface StateContext<T> {\n    /**\n     * Get the current state.\n     */\n    getState(): T;\n    /**\n     * Reset the state to a new value.\n     */\n    setState(val: T | StateOperator<T>): T;\n    /**\n     * Patch the existing state with the provided value.\n     */\n    patchState(val: Partial<T>): T;\n    /**\n     * Dispatch a new action and return the dispatched observable.\n     */\n    dispatch(actions: any | any[]): Observable<void>;\n}\nexport declare type NgxsNextPluginFn = (state: any, mutation: any) => any;\n/**\n * Plugin interface\n */\nexport interface NgxsPlugin {\n    /**\n     * Handle the state/action before its submitted to the state handlers.\n     */\n    handle(state: any, action: any, next: NgxsNextPluginFn): any;\n}\n/**\n * Options that can be provided to the store.\n */\nexport interface StoreOptions<T> {\n    /**\n     * Name of the state. Required.\n     */\n    name: string | StateToken<T>;\n    /**\n     * Default values for the state. If not provided, uses empty object.\n     */\n    defaults?: T;\n    /**\n     * Sub states for the given state.\n     */\n    children?: StateClass[];\n}\n/**\n * Represents a basic change from a previous to a new value for a single state instance.\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\n */\nexport declare class NgxsSimpleChange<T = any> {\n    readonly previousValue: T;\n    readonly currentValue: T;\n    readonly firstChange: boolean;\n    constructor(previousValue: T, currentValue: T, firstChange: boolean);\n}\n/**\n * On init interface\n */\nexport interface NgxsOnInit {\n    ngxsOnInit(ctx: StateContext<any>): void;\n}\n/**\n * On change interface\n */\nexport interface NgxsOnChanges {\n    ngxsOnChanges(change: NgxsSimpleChange): void;\n}\n/**\n * After bootstrap interface\n */\nexport interface NgxsAfterBootstrap {\n    ngxsAfterBootstrap(ctx: StateContext<any>): void;\n}\nexport declare type NgxsModuleOptions = Partial<NgxsConfig>;\n"]}