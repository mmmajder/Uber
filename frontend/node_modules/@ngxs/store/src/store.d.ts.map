{"version":3,"file":"store.d.ts","sources":["store.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { Type } from '@angular/core';\nimport { Observable, Subscription } from 'rxjs';\nimport { InternalNgxsExecutionStrategy } from './execution/internal-ngxs-execution-strategy';\nimport { InternalStateOperations } from './internal/state-operations';\nimport { StateStream } from './internal/state-stream';\nimport { NgxsConfig } from './symbols';\nimport { StateToken } from './state-token/state-token';\nimport { StateFactory } from './internal/state-factory';\nexport declare class Store {\n    private _stateStream;\n    private _internalStateOperations;\n    private _config;\n    private _internalExecutionStrategy;\n    private _stateFactory;\n    /**\n     * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,\n     * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.\n     * All selects would use this stream, and it would call leave only once for any state change across all active selectors.\n     */\n    private _selectableStateStream;\n    constructor(_stateStream: StateStream, _internalStateOperations: InternalStateOperations, _config: NgxsConfig, _internalExecutionStrategy: InternalNgxsExecutionStrategy, _stateFactory: StateFactory, initialStateValue: any);\n    /**\n     * Dispatches event(s).\n     */\n    dispatch(actionOrActions: any | any[]): Observable<any>;\n    /**\n     * Selects a slice of data from the store.\n     */\n    select<T>(selector: (state: any, ...states: any[]) => T): Observable<T>;\n    select<T = any>(selector: string | Type<any>): Observable<T>;\n    select<T>(selector: StateToken<T>): Observable<T>;\n    /**\n     * Select one slice of data from the store.\n     */\n    selectOnce<T>(selector: (state: any, ...states: any[]) => T): Observable<T>;\n    selectOnce<T = any>(selector: string | Type<any>): Observable<T>;\n    selectOnce<T>(selector: StateToken<T>): Observable<T>;\n    /**\n     * Select a snapshot from the state.\n     */\n    selectSnapshot<T>(selector: (state: any, ...states: any[]) => T): T;\n    selectSnapshot<T = any>(selector: string | Type<any>): T;\n    selectSnapshot<T>(selector: StateToken<T>): T;\n    /**\n     * Allow the user to subscribe to the root of the state\n     */\n    subscribe(fn?: (value: any) => void): Subscription;\n    /**\n     * Return the raw value of the state.\n     */\n    snapshot(): any;\n    /**\n     * Reset the state to a specific point in time. This method is useful\n     * for plugin's who need to modify the state directly or unit testing.\n     */\n    reset(state: any): any;\n    private getStoreBoundSelectorFn;\n    private initStateStream;\n}\n"]}